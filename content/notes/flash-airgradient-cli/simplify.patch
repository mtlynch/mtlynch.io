diff --git c/examples/OneOpenAir/OneOpenAir.ino w/examples/OneOpenAir/OneOpenAir.ino
index acd7ecf..653574e 100644
--- c/examples/OneOpenAir/OneOpenAir.ino
+++ w/examples/OneOpenAir/OneOpenAir.ino
@@ -36,9 +36,7 @@ CC BY-SA 4.0 Attribution-ShareAlike 4.0 International License
 #include "Arduino.h"
 #include "EEPROM.h"
 #include "ESPmDNS.h"
-#include "Libraries/airgradient-client/src/common.h"
 #include "LocalServer.h"
-#include "MqttClient.h"
 #include "OpenMetrics.h"
 #include "WebServer.h"
 #include "esp32c3/rom/rtc.h"
@@ -48,14 +46,6 @@ CC BY-SA 4.0 Attribution-ShareAlike 4.0 International License
 #include <cstdint>
 #include <string>
 
-#include "Libraries/airgradient-client/src/agSerial.h"
-#include "Libraries/airgradient-client/src/cellularModule.h"
-#include "Libraries/airgradient-client/src/cellularModuleA7672xx.h"
-#include "Libraries/airgradient-client/src/airgradientCellularClient.h"
-#include "Libraries/airgradient-client/src/airgradientWifiClient.h"
-#include "Libraries/airgradient-ota/src/airgradientOta.h"
-#include "Libraries/airgradient-ota/src/airgradientOtaWifi.h"
-#include "Libraries/airgradient-ota/src/airgradientOtaCellular.h"
 #include "esp_system.h"
 #include "freertos/projdefs.h"
 
@@ -64,23 +54,12 @@ CC BY-SA 4.0 Attribution-ShareAlike 4.0 International License
 #define WIFI_SERVER_CONFIG_SYNC_INTERVAL 1 * 60000     /** ms */
 #define WIFI_MEASUREMENT_INTERVAL 1 * 60000            /** ms */
 #define WIFI_TRANSMISSION_INTERVAL 1 * 60000           /** ms */
-#define CELLULAR_SERVER_CONFIG_SYNC_INTERVAL 30 * 60000 /** ms */
-#define CELLULAR_MEASUREMENT_INTERVAL 3 * 60000        /** ms */
-#define CELLULAR_TRANSMISSION_INTERVAL 3 * 60000       /** ms */
-#define MQTT_SYNC_INTERVAL 60000                       /** ms */
 #define SENSOR_CO2_CALIB_COUNTDOWN_MAX 5               /** sec */
 #define SENSOR_TVOC_UPDATE_INTERVAL 1000               /** ms */
 #define SENSOR_CO2_UPDATE_INTERVAL 4000                /** ms */
 #define SENSOR_PM_UPDATE_INTERVAL 2000                 /** ms */
 #define SENSOR_TEMP_HUM_UPDATE_INTERVAL 6000           /** ms */
 #define DISPLAY_DELAY_SHOW_CONTENT_MS 2000             /** ms */
-#define FIRMWARE_CHECK_FOR_UPDATE_MS (60 * 60 * 1000)  /** ms */
-#define TIME_TO_START_POWER_CYCLE_CELLULAR_MODULE (1 * 60) /** minutes */ 
-#define TIMEOUT_WAIT_FOR_CELLULAR_MODULE_READY    (2 * 60) /** minutes */ 
-
-#define MEASUREMENT_TRANSMIT_CYCLE 3
-#define MAXIMUM_MEASUREMENT_CYCLE_QUEUE 80
-#define RESERVED_MEASUREMENT_CYCLE_CAPACITY 10
 
 /** I2C define */
 #define I2C_SDA_PIN 7
@@ -94,8 +73,6 @@ CC BY-SA 4.0 Attribution-ShareAlike 4.0 International License
 
 #define MINUTES() ((uint32_t)(esp_timer_get_time() / 1000 / 1000 / 60))
 
-static MqttClient mqttClient(Serial);
-static TaskHandle_t mqttTask = NULL;
 static Configuration configuration(Serial);
 static Measurements measurements(configuration);
 static AirGradient *ag;
@@ -107,71 +84,39 @@ static WifiConnector wifiConnector(oledDisplay, Serial, stateMachine,
 static OpenMetrics openMetrics(measurements, configuration, wifiConnector);
 static LocalServer localServer(Serial, openMetrics, measurements, configuration,
                                wifiConnector);
-static AgSerial *agSerial;
-static CellularModule *cellularCard;
-static AirgradientClient *agClient;
 
-enum NetworkOption {
-  UseWifi,
-  UseCellular
-};
-NetworkOption networkOption;
 TaskHandle_t handleNetworkTask = NULL;
-static bool firmwareUpdateInProgress = false;
 
 static uint32_t factoryBtnPressTime = 0;
 static AgFirmwareMode fwMode = FW_MODE_I_9PSL;
 static bool ledBarButtonTest = false;
-static String fwNewVersion;
-static int lastCellSignalQuality = 99; // CSQ 
-
-// Default value is 0, indicate its not started yet
-// In minutes
-uint32_t agCeClientProblemDetectedTime = 0;
-
-SemaphoreHandle_t mutexMeasurementCycleQueue;
-static std::vector<Measurements::Measures> measurementCycleQueue;
 
 static void boardInit(void);
 static void initializeNetwork();
 static void failedHandler(String msg);
-static void configurationUpdateSchedule(void);
-static void configUpdateHandle(void); 
+static void configUpdateHandle(void);
 static void updateDisplayAndLedBar(void);
 static void updateTvoc(void);
 static void updatePm(void);
-static void sendDataToServer(void);
 static void tempHumUpdate(void);
 static void co2Update(void);
 static void printMeasurements();
 static void mdnsInit(void);
-static void createMqttTask(void);
-static void initMqtt(void);
 static void factoryConfigReset(void);
 static void wdgFeedUpdate(void);
 static void ledBarEnabledUpdate(void);
 static bool sgp41Init(void);
-static void checkForFirmwareUpdate(void);
-static void otaHandlerCallback(AirgradientOTA::OtaResult result, const char *msg);
-static void displayExecuteOta(AirgradientOTA::OtaResult result, String msg, int processing);
 static int calculateMaxPeriod(int updateInterval);
 static void setMeasurementMaxPeriod();
-static void newMeasurementCycle();
-static void restartIfCeClientIssueOverTwoHours(); 
 static void networkSignalCheck();
 static void networkingTask(void *args);
 
 AgSchedule dispLedSchedule(DISP_UPDATE_INTERVAL, updateDisplayAndLedBar);
-AgSchedule configSchedule(WIFI_SERVER_CONFIG_SYNC_INTERVAL,
-                          configurationUpdateSchedule);
-AgSchedule transmissionSchedule(WIFI_TRANSMISSION_INTERVAL, sendDataToServer);
-AgSchedule measurementSchedule(WIFI_MEASUREMENT_INTERVAL, newMeasurementCycle);
 AgSchedule co2Schedule(SENSOR_CO2_UPDATE_INTERVAL, co2Update);
 AgSchedule pmsSchedule(SENSOR_PM_UPDATE_INTERVAL, updatePm);
 AgSchedule tempHumSchedule(SENSOR_TEMP_HUM_UPDATE_INTERVAL, tempHumUpdate);
 AgSchedule tvocSchedule(SENSOR_TVOC_UPDATE_INTERVAL, updateTvoc);
 AgSchedule watchdogFeedSchedule(60000, wdgFeedUpdate);
-AgSchedule checkForUpdateSchedule(FIRMWARE_CHECK_FOR_UPDATE_MS, checkForFirmwareUpdate);
 AgSchedule networkSignalCheckSchedule(10000, networkSignalCheck);
 AgSchedule printMeasurementsSchedule(6000, printMeasurements);
 
@@ -180,25 +125,30 @@ void setup() {
   Serial.begin(115200);
   delay(100); /** For bester show log */
 
-  // Enable cullular module power board 
-  pinMode(GPIO_EXPANSION_CARD_POWER, OUTPUT);
-  digitalWrite(GPIO_EXPANSION_CARD_POWER, HIGH);
-
-  /** Print device ID into log */
-  Serial.println("Serial nr: " + ag->deviceId());
+  Serial.println("DEBUG 1: Serial initialized");
+  Serial.flush();
 
   // Set reason why esp is reset
   esp_reset_reason_t reason = esp_reset_reason();
   measurements.setResetReason(reason);
 
+  Serial.println("DEBUG 2: Reset reason set");
+  Serial.flush();
+
   /** Initialize local configure */
   configuration.begin();
   configuration.setConfigurationUpdatedCallback(configUpdateHandle);
 
+  Serial.println("DEBUG 3: Configuration initialized");
+  Serial.flush();
+
   /** Init I2C */
   Wire.begin(I2C_SDA_PIN, I2C_SCL_PIN);
   delay(1000);
 
+  Serial.println("DEBUG 4: I2C initialized");
+  Serial.flush();
+
   /** Detect board type: ONE_INDOOR has OLED display, Scan the I2C address to
    * identify board type */
   Wire.beginTransmission(OLED_I2C_ADDR);
@@ -207,7 +157,8 @@ void setup() {
   } else {
     ag = new AirGradient(BoardType::OPEN_AIR_OUTDOOR);
   }
-  Serial.println("Detected " + ag->getBoardName());
+  Serial.println("DEBUG 5: Board detected - " + ag->getBoardName());
+  Serial.flush();
 
   configuration.setAirGradient(ag);
   oledDisplay.setAirGradient(ag);
@@ -217,12 +168,25 @@ void setup() {
   localServer.setAirGraident(ag);
   measurements.setAirGradient(ag);
 
+  Serial.println("DEBUG 6: AirGradient objects configured");
+  Serial.flush();
+
   /** Init sensor */
   boardInit();
+  Serial.println("DEBUG 7: Board initialization complete");
+  Serial.flush();
+
   setMeasurementMaxPeriod();
+  Serial.println("DEBUG 8: Measurement periods set");
+  Serial.flush();
+
+  Serial.println("DEBUG 9: Starting offline mode check");
+  Serial.flush();
 
   bool connectToNetwork = true;
   if (ag->isOne()) { // Offline mode only available for indoor monitor
+    Serial.println("DEBUG 10: Indoor monitor detected, checking offline mode");
+    Serial.flush();
     /** Show message confirm offline mode, should me perform if LED bar button
      * test pressed */
     if (ledBarButtonTest == false) {
@@ -252,18 +216,28 @@ void setup() {
     }
   }
 
+  Serial.println("DEBUG 11: Offline mode check complete, connectToNetwork=" + String(connectToNetwork));
+  Serial.flush();
+
   // Initialize networking configuration
   if (connectToNetwork) {
     oledDisplay.setText("Initialize", "network...", "");
+    Serial.println("DEBUG 12: Starting network initialization");
+    Serial.flush();
     initializeNetwork();
+    Serial.println("DEBUG 13: Network initialization complete");
+    Serial.flush();
   }
 
   /** Set offline mode without saving, cause wifi is not configured */
-  if (wifiConnector.hasConfigurated() == false && networkOption == UseWifi) {
+  if (wifiConnector.hasConfigurated() == false) {
     Serial.println("Set offline mode cause wifi is not configurated");
     configuration.setOfflineModeWithoutSave(true);
   }
 
+  Serial.println("DEBUG 14: Starting display setup");
+  Serial.flush();
+
   /** Show display Warning up */
   if (ag->isOne()) {
     oledDisplay.setText("Warming Up", "Serial Number:", ag->deviceId().c_str());
@@ -274,31 +248,24 @@ void setup() {
     delay(DISPLAY_DELAY_SHOW_CONTENT_MS);
   }
 
-
-  if (networkOption == UseCellular) {
-    // If using cellular re-set scheduler interval
-    configSchedule.setPeriod(CELLULAR_SERVER_CONFIG_SYNC_INTERVAL);
-    transmissionSchedule.setPeriod(CELLULAR_TRANSMISSION_INTERVAL);
-    measurementSchedule.setPeriod(CELLULAR_MEASUREMENT_INTERVAL);
-    measurementSchedule.update();
-    // Queue now only applied for cellular
-    // Allocate queue memory to avoid always reallocation
-    measurementCycleQueue.reserve(RESERVED_MEASUREMENT_CYCLE_CAPACITY);
-    // Initialize mutex to access mesurementCycleQueue 
-    mutexMeasurementCycleQueue = xSemaphoreCreateMutex();
-  }
+  Serial.println("DEBUG 15: Starting task creation");
+  Serial.flush();
 
   // Only run network task if monitor is not in offline mode
   if (configuration.isOfflineMode() == false) {
     BaseType_t xReturned =
-      xTaskCreate(networkingTask, "NetworkingTask", 4096, null, 5, &handleNetworkTask);
+      xTaskCreate(networkingTask, "NetworkingTask", 4096, NULL, 5, &handleNetworkTask);
     if (xReturned == pdPASS) {
       Serial.println("Success create networking task");
     } else {
-      assert("Failed to create networking task");
+      Serial.println("DEBUG ERROR: Failed to create networking task");
+      Serial.flush();
     }
   }
 
+  Serial.println("DEBUG 16: Setup complete, entering main loop");
+  Serial.flush();
+
   // Log monitor mode for debugging purpose
   if (configuration.isOfflineMode()) {
     Serial.println("Running monitor in offline mode");
@@ -310,29 +277,12 @@ void setup() {
 }
 
 void loop() {
-  if (networkOption == UseCellular) {
-    // Check if cellular client not ready until certain time
-    // Redundant check in both task to make sure its executed 
-    restartIfCeClientIssueOverTwoHours();
-  }
-
   // Schedule to feed external watchdog
   watchdogFeedSchedule.run();
 
-  if (firmwareUpdateInProgress) {
-    // Firmare update currently in progress, temporarily disable running sensor schedules
-    delay(10000);
-    return;
-  }
-
   // Schedule to update display and led
   dispLedSchedule.run();
 
-  if (networkOption == UseCellular) {
-    // Queue now only applied for cellular
-    measurementSchedule.run();
-  }
-
   if (configuration.hasSensorS8) {
     co2Schedule.run();
   }
@@ -410,60 +360,6 @@ static void mdnsInit(void) {
   MDNS.addServiceTxt("_airgradient", "_tcp", "vendor", "AirGradient");
 }
 
-static void createMqttTask(void) {
-  if (mqttTask) {
-    vTaskDelete(mqttTask);
-    mqttTask = NULL;
-    Serial.println("Delete old MQTT task");
-  }
-
-  Serial.println("Create new MQTT task");
-  xTaskCreate(
-      [](void *param) {
-        for (;;) {
-          delay(MQTT_SYNC_INTERVAL);
-
-          /** Send data */
-          if (mqttClient.isConnected()) {
-            String payload = measurements.toString(true, fwMode, wifiConnector.RSSI());
-            String topic = "airgradient/readings/" + ag->deviceId();
-
-            if (mqttClient.publish(topic.c_str(), payload.c_str(),
-                                   payload.length())) {
-              Serial.println("MQTT sync success");
-            } else {
-              Serial.println("MQTT sync failure");
-            }
-          }
-        }
-      },
-      "mqtt-task", 1024 * 4, NULL, 6, &mqttTask);
-
-  if (mqttTask == NULL) {
-    Serial.println("Creat mqttTask failed");
-  }
-}
-
-static void initMqtt(void) {
-  String mqttUri = configuration.getMqttBrokerUri();
-  if (mqttUri.isEmpty()) {
-    Serial.println(
-        "MQTT is not configured, skipping initialization of MQTT client");
-    return;
-  }
-
-  if (networkOption == UseCellular) {
-    Serial.println("MQTT not available for cellular options");
-    return;
-  }
-
-  if (mqttClient.begin(mqttUri)) {
-    Serial.println("Successfully connected to MQTT broker");
-    createMqttTask();
-  } else {
-    Serial.println("Connection to MQTT broker failed");
-  }
-}
 
 static void factoryConfigReset(void) {
   if (ag->button.getState() == ag->button.BUTTON_PRESSED) {
@@ -491,12 +387,6 @@ static void factoryConfigReset(void) {
           }
           count--;
           if (count == 0) {
-            /** Stop MQTT task first */
-            if (mqttTask) {
-              vTaskDelete(mqttTask);
-              mqttTask = NULL;
-            }
-
             /** Reset WIFI */
             WiFi.disconnect(true, true);
 
@@ -565,186 +455,6 @@ static bool sgp41Init(void) {
   return false;
 }
 
-void checkForFirmwareUpdate(void) {
-  if (configuration.isCloudConnectionDisabled()) {
-    Serial.println("Cloud connection is disabled, skip firmware update");
-    return;
-  }
-
-  AirgradientOTA *agOta;
-  if (networkOption == UseWifi) {
-    agOta = new AirgradientOTAWifi;
-  } else {
-    agOta = new AirgradientOTACellular(cellularCard);
-  }
-
-  // Indicate main task that firmware update is in progress
-  firmwareUpdateInProgress = true;
-
-  agOta->setHandlerCallback(otaHandlerCallback);
-
-  String httpDomain = configuration.getHttpDomain();
-  if (httpDomain != "") {
-    Serial.printf("httpDomain configuration available, start OTA with custom domain\n",
-                  httpDomain.c_str());
-    agOta->updateIfAvailable(ag->deviceId().c_str(), GIT_VERSION, httpDomain.c_str());
-  } else {
-    agOta->updateIfAvailable(ag->deviceId().c_str(), GIT_VERSION);
-  }
-
-  // Only goes to this line if firmware update is not success
-  // Handled by otaHandlerCallback
-
-  // Indicate main task that firmware update finish
-  firmwareUpdateInProgress = false;
-
-  delete agOta;
-  Serial.println();
-}
-
-void otaHandlerCallback(AirgradientOTA::OtaResult result, const char *msg) {
-  switch (result) {
-  case AirgradientOTA::Starting: {
-    Serial.println("Firmware update starting...");
-    if (configuration.hasSensorSGP && networkOption == UseCellular) {
-      // Temporary pause SGP41 task while cellular firmware update is in progress
-      ag->sgp41.pause();
-    }
-    displayExecuteOta(result, fwNewVersion, 0);
-    break;
-  }
-  case AirgradientOTA::InProgress:
-    Serial.printf("OTA progress: %s\n", msg);
-    displayExecuteOta(result, "", std::stoi(msg));
-    break;
-  case AirgradientOTA::Failed:
-      displayExecuteOta(result, "", 0);
-      if (configuration.hasSensorSGP && networkOption == UseCellular) {
-        ag->sgp41.resume();
-      }
-      break;
-  case AirgradientOTA::Skipped:
-  case AirgradientOTA::AlreadyUpToDate:
-    displayExecuteOta(result, "", 0);
-    break;
-  case AirgradientOTA::Success:
-    displayExecuteOta(result, "", 0);
-    esp_restart();
-    break;
-  default:
-    break;
-  }
-}
-
-static void displayExecuteOta(AirgradientOTA::OtaResult result, String msg, int processing) {
-  switch (result) {
-    case AirgradientOTA::Starting:
-    if (ag->isOne()) {
-      oledDisplay.showFirmwareUpdateVersion(msg);
-    } else {
-      Serial.println("New firmware: " + msg);
-    }
-    delay(2500);
-    break;
-  case AirgradientOTA::Failed:
-    if (ag->isOne()) {
-      oledDisplay.showFirmwareUpdateFailed();
-    } else {
-      Serial.println("Error: Firmware update: failed");
-    }
-    delay(2500);
-    break;
-  case AirgradientOTA::Skipped:
-    if (ag->isOne()) {
-      oledDisplay.showFirmwareUpdateSkipped();
-    } else {
-      Serial.println("Firmware update: Skipped");
-    }
-    delay(2500);
-    break;
-  case AirgradientOTA::AlreadyUpToDate:
-    if (ag->isOne()) {
-      oledDisplay.showFirmwareUpdateUpToDate();
-    } else {
-      Serial.println("Firmware update: up to date");
-    }
-    delay(2500);
-    break;
-  case AirgradientOTA::InProgress:
-    if (ag->isOne()) {
-      oledDisplay.showFirmwareUpdateProgress(processing);
-    } else {
-      Serial.println("Firmware update: " + String(processing) + String("%"));
-    }
-    break;
-  case AirgradientOTA::Success: {
-    Serial.println("OTA update performed, restarting ...");
-    int i = 3;
-    while (i != 0) {
-      i = i - 1;
-      if (ag->isOne()) {
-        oledDisplay.showFirmwareUpdateSuccess(i);
-      } else {
-        Serial.println("Rebooting... " + String(i));
-      }
-      delay(1000);
-    }
-
-    if (ag->isOne()) {
-      oledDisplay.setAirGradient(0);
-      oledDisplay.setBrightness(0);
-    }
-    break;
-  }
-  default:
-    break;
-  }
-}
-
-static void sendDataToAg() {
-  /** Change oledDisplay and led state */
-  if (ag->isOne()) {
-    stateMachine.displayHandle(AgStateMachineWiFiOkServerConnecting);
-  }
-  stateMachine.handleLeds(AgStateMachineWiFiOkServerConnecting);
-
-  /** Task handle led connecting animation */
-  xTaskCreate(
-      [](void *obj) {
-        for (;;) {
-          // ledSmHandler();
-          stateMachine.handleLeds();
-          if (stateMachine.getLedState() !=
-              AgStateMachineWiFiOkServerConnecting) {
-            break;
-          }
-          delay(LED_BAR_ANIMATION_PERIOD);
-        }
-        vTaskDelete(NULL);
-      },
-      "task_led", 2048, NULL, 5, NULL);
-
-  delay(1500);
-  
-  // Build payload to check connection to airgradient server
-  JSONVar root;
-  root["wifi"] = wifiConnector.RSSI();
-  root["boot"] = measurements.bootCount();
-  std::string payload = JSON.stringify(root).c_str();
-  if (agClient->httpPostMeasures(payload)) {
-    if (ag->isOne()) {
-      stateMachine.displayHandle(AgStateMachineWiFiOkServerConnected);
-    }
-    stateMachine.handleLeds(AgStateMachineWiFiOkServerConnected);
-  } else {
-    if (ag->isOne()) {
-      stateMachine.displayHandle(AgStateMachineWiFiOkServerConnectFailed);
-    }
-    stateMachine.handleLeds(AgStateMachineWiFiOkServerConnectFailed);
-  }
-
-  stateMachine.handleLeds(AgStateMachineNormal);
-}
 
 void dispSensorNotFound(String ss) {
   ss = ss + " not found";
@@ -965,152 +675,39 @@ static void failedHandler(String msg) {
 }
 
 void initializeNetwork() {
-  // Check if cellular module available
-  agSerial = new AgSerial(Wire);
-  agSerial->init(GPIO_IIC_RESET);
-  if (agSerial->open()) {
-    Serial.println("Cellular module found");
-    // Initialize cellular module and use cellular as agClient 
-    cellularCard = new CellularModuleA7672XX(agSerial, GPIO_POWER_MODULE_PIN);
-    agClient = new AirgradientCellularClient(cellularCard);
-    networkOption = UseCellular;
-  } else {
-    Serial.println("Cellular module not available, using wifi");
-    delete agSerial;
-    agSerial = nullptr;
-    // Use wifi as agClient
-    agClient = new AirgradientWifiClient;
-    networkOption = UseWifi;
-  }
 
-  if (networkOption == UseCellular) {
-    // Enable serial stream debugging to check the AT command when doing registration 
-    agSerial->setDebug(true);
-  }
-
-  String httpDomain = configuration.getHttpDomain();
-  if (httpDomain != "") {
-    agClient->setHttpDomain(httpDomain.c_str());
-    Serial.printf("HTTP domain name is set to: %s\n", httpDomain.c_str());
-    oledDisplay.setText("HTTP domain name", "using local", "configuration");
-    delay(2500);
-  }
-
-  if (!agClient->begin(ag->deviceId().c_str())) {
-    oledDisplay.setText("Client", "initialization", "failed");
-    delay(5000);
-    oledDisplay.showRebooting();
-    delay(2500);
-    oledDisplay.setText("", "", "");
-    ESP.restart();
-  }
-
-  // Provide openmetrics to have access to last transmission result 
-  openMetrics.setAirgradientClient(agClient);
-
-  if (networkOption == UseCellular) {
-    // Disabling it again
-    agSerial->setDebug(false);
-  }
-
-  if (networkOption == UseWifi) {
-    if (!wifiConnector.connect()) {
-      Serial.println("Cannot initiate wifi connection");
-      return;
-    }
-  
-    if (!wifiConnector.isConnected()) {
-      Serial.println("Failed connect to WiFi");
-      if (wifiConnector.isConfigurePorttalTimeout()) {
-        oledDisplay.showRebooting();
-        delay(2500);
-        oledDisplay.setText("", "", "");
-        ESP.restart();
-      }
-  
-      // Directly return because the rest of the function applied if wifi is connect only
-      return;
-    }
-  
-    // Initiate local network configuration
-    mdnsInit();
-    localServer.begin();
-    // Apply mqtt connection if configured
-    initMqtt();
-  
-    // Ignore the rest if cloud connection to AirGradient is disabled
-    if (configuration.isCloudConnectionDisabled()) {
-      return;
-    }
-
-    // Send data for the first time to AG server at boot only if postDataToAirgradient is enabled
-    if (configuration.isPostDataToAirGradient()) {
-      sendDataToAg();
-    }
-  }
-
-  // Skip fetch configuration if configuration control is set to "local" only
-  if (configuration.getConfigurationControl() == ConfigurationControl::ConfigurationControlLocal) {
-    ledBarEnabledUpdate();
+  if (!wifiConnector.connect()) {
+    Serial.println("Cannot initiate wifi connection");
     return;
   }
 
-  std::string config = agClient->httpFetchConfig();
-  configSchedule.update();
-  // Check if fetch configuration failed or fetch succes but parsing failed
-  if (agClient->isLastFetchConfigSucceed() == false ||
-      configuration.parse(config.c_str(), false) == false) {
-    if (ag->isOne()) {
-      if (agClient->isRegisteredOnAgServer() == false) {
-        stateMachine.displaySetAddToDashBoard();
-        stateMachine.displayHandle(AgStateMachineWiFiOkServerOkSensorConfigFailed);
-      } else {
-        stateMachine.displayClearAddToDashBoard();
-      }
+  if (!wifiConnector.isConnected()) {
+    Serial.println("Failed connect to WiFi");
+    if (wifiConnector.isConfigurePorttalTimeout()) {
+      oledDisplay.showRebooting();
+      delay(2500);
+      oledDisplay.setText("", "", "");
+      ESP.restart();
     }
-    stateMachine.handleLeds(AgStateMachineWiFiOkServerOkSensorConfigFailed);
-    delay(DISPLAY_DELAY_SHOW_CONTENT_MS);
-  }
-  else {
-    ledBarEnabledUpdate();
-  }
-}
 
-static void configurationUpdateSchedule(void) {
-  if (configuration.getConfigurationControl() ==
-      ConfigurationControl::ConfigurationControlLocal) {
-    Serial.println("Ignore fetch server configuration, configurationControl set to local");
-    agClient->resetFetchConfigurationStatus();
+    // Directly return because the rest of the function applied if wifi is connect only
     return;
   }
 
-  std::string config = agClient->httpFetchConfig();
-  if (agClient->isLastFetchConfigSucceed()) {
-    configuration.parse(config.c_str(), false);
-  }
+  // Initiate local network configuration
+  mdnsInit();
+  localServer.begin();
+
+  // Cloud connection is always disabled, so return early
+  return;
 }
 
+
 static void configUpdateHandle() {
   if (configuration.isUpdated() == false) {
     return;
   }
 
-  String mqttUri = configuration.getMqttBrokerUri();
-  if (mqttClient.isCurrentUri(mqttUri) == false) {
-    mqttClient.end();
-    initMqtt();
-  }
-
-  String httpDomain = configuration.getHttpDomain();
-  if (httpDomain != "") {
-    Serial.printf("HTTP domain name set to: %s\n", httpDomain.c_str());
-    agClient->setHttpDomain(httpDomain.c_str());
-  } else {
-    // Its empty, set to default
-    Serial.println("HTTP domain name from configuration empty, set to default");
-    agClient->setHttpDomainDefault();
-  }
-
   if (configuration.hasSensorSGP) {
     if (configuration.noxLearnOffsetChanged() ||
         configuration.tvocLearnOffsetChanged()) {
@@ -1185,44 +782,15 @@ static void updateDisplayAndLedBar(void) {
     return;
   }
 
-  if (networkOption == UseWifi) {
-    if (wifiConnector.isConnected() == false) {
-      stateMachine.displayHandle(AgStateMachineWiFiLost);
-      stateMachine.handleLeds(AgStateMachineWiFiLost);
-      return;
-    }
-  }
-  else if (networkOption == UseCellular) {
-    if (agClient->isClientReady() == false)  {
-      // Same action as wifi
-      stateMachine.displayHandle(AgStateMachineWiFiLost);
-      stateMachine.handleLeds(AgStateMachineWiFiLost);
-      return;
-    }
-  }
-
-  if (configuration.isCloudConnectionDisabled()) {
-    // Ignore API related check since cloud is disabled 
-    stateMachine.displayHandle(AgStateMachineNormal);
-    stateMachine.handleLeds(AgStateMachineNormal);
+  if (wifiConnector.isConnected() == false) {
+    stateMachine.displayHandle(AgStateMachineWiFiLost);
+    stateMachine.handleLeds(AgStateMachineWiFiLost);
     return;
   }
 
-  AgStateMachineState state = AgStateMachineNormal;
-  if (agClient->isLastFetchConfigSucceed() == false) {
-    state = AgStateMachineSensorConfigFailed;
-    if (agClient->isRegisteredOnAgServer() == false) {
-      stateMachine.displaySetAddToDashBoard();
-    } else {
-      stateMachine.displayClearAddToDashBoard();
-    }
-  } else if (agClient->isLastPostMeasureSucceed() == false &&
-             configuration.isPostDataToAirGradient()) {
-    state = AgStateMachineServerLost;
-  }
-
-  stateMachine.displayHandle(state);
-  stateMachine.handleLeds(state);
+  // Cloud connection is always disabled, so always use normal state
+  stateMachine.displayHandle(AgStateMachineNormal);
+  stateMachine.handleLeds(AgStateMachineNormal);
 }
 
 static void updateTvoc(void) {
@@ -1373,93 +941,6 @@ static void updatePm(void) {
   }
 }
 
-void postUsingWifi() {
-  // Increment bootcount when send measurements data is scheduled
-  int bootCount = measurements.bootCount() + 1;
-  measurements.setBootCount(bootCount);
-
-  String payload = measurements.toString(false, fwMode, wifiConnector.RSSI());
-  if (agClient->httpPostMeasures(payload.c_str()) == false) {
-    Serial.println();
-    Serial.println("Online mode and isPostToAirGradient = true");
-    Serial.println();
-  }
-
-  // Log current free heap size
-  Serial.printf("Free heap: %u\n", ESP.getFreeHeap());
-}
-
-/**
-* forcePost to force post without checking transmit cycle
-*/
-void postUsingCellular(bool forcePost) {
-  // Aquire queue mutex to get queue size
-  xSemaphoreTake(mutexMeasurementCycleQueue, portMAX_DELAY);
-  
-  // Make sure measurement cycle available
-  int queueSize = measurementCycleQueue.size();
-  if (queueSize == 0) {
-    Serial.println("Skipping transmission, measurementCycle empty");
-    xSemaphoreGive(mutexMeasurementCycleQueue);
-    return;
-  }
-
-  // Check queue size if its ready to transmit
-  // It is ready if size is divisible by 3 
-  if (!forcePost && (queueSize % MEASUREMENT_TRANSMIT_CYCLE) > 0) {
-    Serial.printf("Not ready to transmit, queue size are %d\n", queueSize);
-    xSemaphoreGive(mutexMeasurementCycleQueue);
-    return;
-  }
-
-  // Build payload include all measurements from queue
-  std::string payload;
-  payload += std::to_string(CELLULAR_MEASUREMENT_INTERVAL / 1000); // Convert to seconds
-  for (int i = 0; i < queueSize; i++) {
-    auto mc = measurementCycleQueue.at(i);
-    payload += ",";
-    payload += measurements.buildMeasuresPayload(mc);
-  }
-
-  // Release before actually post measures that might takes too long
-  xSemaphoreGive(mutexMeasurementCycleQueue);
-
-  // Attempt to send
-  if (agClient->httpPostMeasures(payload) == false) {
-    // Consider network has a problem, retry in next schedule 
-    Serial.println("Post measures failed, retry in next schedule");
-    return;
-  }
-
-  // Post success, remove the data that previously sent from queue
-  xSemaphoreTake(mutexMeasurementCycleQueue, portMAX_DELAY);
-
-  if (measurementCycleQueue.capacity() > RESERVED_MEASUREMENT_CYCLE_CAPACITY) {
-    Serial.println("measurementCycleQueue capacity more than reserved space, resizing..");
-    std::vector<Measurements::Measures> tmp;
-    tmp.reserve(RESERVED_MEASUREMENT_CYCLE_CAPACITY);
-    measurementCycleQueue.swap(tmp);
-  } else {
-    // If not more than the capacity, then just clear all the values
-    measurementCycleQueue.clear();
-  }
-
-  xSemaphoreGive(mutexMeasurementCycleQueue);
-}
-
-void sendDataToServer(void) {
-  if (configuration.isPostDataToAirGradient() == false) {
-    Serial.println("Skipping transmission of data to AG server, post data to server disabled");
-    agClient->resetPostMeasuresStatus();
-    return;
-  }
-
-  if (networkOption == UseWifi) {
-    postUsingWifi();
-  } else if (networkOption == UseCellular) {
-    postUsingCellular(false);
-  }
-}
 
 static void tempHumUpdate(void) {
   delay(100);
@@ -1527,171 +1008,28 @@ void setMeasurementMaxPeriod() {
 
 int calculateMaxPeriod(int updateInterval) {
   // 0.8 is 80% reduced interval for max period
-  // NOTE: Both network option use the same measurement interval 
+  // NOTE: Both network option use the same measurement interval
   return (WIFI_MEASUREMENT_INTERVAL - (WIFI_MEASUREMENT_INTERVAL * 0.8)) / updateInterval;
 }
 
 
 void networkSignalCheck() {
-  if (networkOption == UseWifi) {
-    Serial.printf("WiFi RSSI %d\n", wifiConnector.RSSI());
-  } else if (networkOption == UseCellular) {
-    auto result = cellularCard->retrieveSignal();
-    if (result.status != CellReturnStatus::Ok) {
-      agClient->setClientReady(false);
-      lastCellSignalQuality = 99;
-      return;
-    }
-
-    // Save last signal quality
-    lastCellSignalQuality = result.data; 
-
-    if (result.data == 99) {
-      // 99 indicate cellular not attached to network
-      agClient->setClientReady(false);
-      return;
-    }
-
-    Serial.printf("Cellular signal quality %d\n", result.data);
-  }
+  Serial.printf("WiFi RSSI %d\n", wifiConnector.RSSI());
 }
 
-/**
-* If in 2 hours cellular client still not ready, then restart system 
-*/
-void restartIfCeClientIssueOverTwoHours() {
-  if (agCeClientProblemDetectedTime > 0 &&
-      (MINUTES() - agCeClientProblemDetectedTime) >
-          TIMEOUT_WAIT_FOR_CELLULAR_MODULE_READY) {
-    // Give up wait
-    Serial.println("Rebooting because CE client issues for 2 hours detected");
-    int i = 3;
-    while (i != 0) {
-      if (ag->isOne()) {
-        String tmp = "Rebooting in " + String(i);
-        oledDisplay.setText("CE error", "since 2h", tmp.c_str());
-      } else {
-        Serial.println("Rebooting... " + String(i));
-      }
-      i = i - 1;
-      delay(1000);
-    }
-    oledDisplay.setBrightness(0);
-    esp_restart();
-  }
-}
 
 void networkingTask(void *args) {
-  // If cloud connection enabled, run first transmission to server at boot
-  if (configuration.isCloudConnectionDisabled() == false) {
-    // OTA check on boot
-#ifndef ESP8266
-    checkForFirmwareUpdate();
-    checkForUpdateSchedule.update();
-#endif
-
-    // Because cellular interval is longer, needs to send first measures cycle on
-    // boot to indicate that its online
-    if (networkOption == UseCellular) {
-      Serial.println("Prepare first measures cycle to send on boot for 20s");
-      delay(20000);
-      networkSignalCheck();
-      newMeasurementCycle();
-      postUsingCellular(true);
-      measurementSchedule.update();
-    }
-    // Reset scheduler
-    configSchedule.update();
-    transmissionSchedule.update();
-  }
-
   while (1) {
-    // Handle reconnection based on mode
-    if (networkOption == UseWifi) {
-      wifiConnector.handle();
-      if (wifiConnector.isConnected() == false) {
-        delay(1000);
-        continue;
-      }
-    }
-    else if (networkOption == UseCellular) {
-      if (agClient->isClientReady() == false) {
-        // Start time if value still default
-        if (agCeClientProblemDetectedTime == 0) {
-          agCeClientProblemDetectedTime = MINUTES();
-        }
-
-        // Enable at command debug
-        agSerial->setDebug(true); 
-
-        // Check if cellular client not ready until certain time
-        // Redundant check in both task to make sure its executed 
-        restartIfCeClientIssueOverTwoHours();
-
-        // Power cycling cellular module due to network issues for more than 1 hour
-        bool resetModule = true;
-        if ((MINUTES() - agCeClientProblemDetectedTime) >
-            TIME_TO_START_POWER_CYCLE_CELLULAR_MODULE) {
-          Serial.println("The CE client hasn't recovered in more than 1 hour, "
-                         "performing a power cycle");
-          cellularCard->powerOff();
-          delay(2000);
-          cellularCard->powerOn();
-          delay(10000);
-          // no need to reset module when calling ensureClientConnection()
-          resetModule = false;
-        }
-
-        // Attempt to reconnect
-        Serial.println("Cellular client not ready, ensuring connection...");
-        if (agClient->ensureClientConnection(resetModule) == false) {
-          Serial.println("Cellular client connection not ready, retry in 30s...");
-          delay(30000); // before retry, wait for 30s
-          continue;
-        }
-
-        // Client is ready
-        agCeClientProblemDetectedTime = 0; // reset to default
-        agSerial->setDebug(false); // disable at command debug
-      }
-    }
-
-    // If connection to AirGradient server disable don't run config and transmission schedule
-    if (configuration.isCloudConnectionDisabled()) {
+    // Handle WiFi reconnection
+    wifiConnector.handle();
+    if (wifiConnector.isConnected() == false) {
       delay(1000);
       continue;
     }
 
-    // Run scheduler
-    networkSignalCheckSchedule.run();
-    configSchedule.run();
-    transmissionSchedule.run();
-    checkForUpdateSchedule.run();
-
+    // Cloud connection is always disabled, so just delay
     delay(1000);
   }
 
   vTaskDelete(handleNetworkTask);
 }
-
-void newMeasurementCycle() {
-  if (xSemaphoreTake(mutexMeasurementCycleQueue, portMAX_DELAY) == pdTRUE) {
-    // Make sure queue not overflow 
-    if (measurementCycleQueue.size() >= MAXIMUM_MEASUREMENT_CYCLE_QUEUE) {
-      // Remove the oldest data from queue if queue reach max
-      measurementCycleQueue.erase(measurementCycleQueue.begin());
-    }
-
-    // Get current measures
-    auto mc = measurements.getMeasures(); 
-    mc.signal = cellularCard->csqToDbm(lastCellSignalQuality); // convert to RSSI
-
-    measurementCycleQueue.push_back(mc);
-    Serial.println("New measurement cycle added to queue");
-    // Release mutex
-    xSemaphoreGive(mutexMeasurementCycleQueue);
-    // Log current free heap size
-    Serial.printf("Free heap: %u\n", ESP.getFreeHeap());
-  }
-}
-
